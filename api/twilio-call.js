const { executeQuery, createConnection } = require('../lib/database');
const { combinarFechaHora, validarReserva, generarConversacionCompleta } = require('../lib/utils');

// Estado de conversaciones por CallSid (en memoria - para producci√≥n usa Redis/DB)
const conversationStates = new Map();

module.exports = async function handler(req, res) {
  console.log('üìû Twilio Call recibida');
  console.log('Method:', req.method);
  console.log('Body:', req.body);

  try {
    // Extraer par√°metros de Twilio
    const { 
      CallSid, 
      SpeechResult, 
      Digits,
      From,
      To,
      CallStatus 
    } = req.body;

    // Obtener o crear estado de conversaci√≥n
    let state = conversationStates.get(CallSid) || {
      step: 'greeting',
      data: {},
      phone: From,
      conversationHistory: []
    };

    // Guardar entrada del usuario si existe
    const userInput = SpeechResult || Digits || '';
    if (userInput) {
      state.conversationHistory.push({
        role: 'user',
        message: userInput,
        timestamp: new Date().toISOString()
      });
    }

    // Procesar seg√∫n el paso actual
    const response = await processConversationStep(state, userInput);
    
    // Guardar el mensaje del bot
    state.conversationHistory.push({
      role: 'bot',
      message: response.message,
      timestamp: new Date().toISOString()
    });

    // Actualizar estado
    conversationStates.set(CallSid, state);

    // Si la conversaci√≥n est√° completa, guardar en BD
    if (state.step === 'complete') {
      await saveReservation(state);
      // Limpiar el estado despu√©s de guardar
      setTimeout(() => conversationStates.delete(CallSid), 60000); // Limpiar despu√©s de 1 minuto
    }

    // Generar TwiML response
    const twiml = generateTwiML(response);
    
    res.setHeader('Content-Type', 'text/xml');
    res.status(200).send(twiml);

  } catch (error) {
    console.error('‚ùå Error en Twilio Call:', error);
    
    const errorTwiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="Google.es-ES-Neural2-B" language="es-ES">
    Disculpe, hubo un error t√©cnico. Por favor, intente de nuevo m√°s tarde o contacte directamente al restaurante.
  </Say>
  <Hangup/>
</Response>`;
    
    res.setHeader('Content-Type', 'text/xml');
    res.status(200).send(errorTwiml);
  }
}

async function processConversationStep(state, userInput) {
  const step = state.step;
  const text = userInput.toLowerCase();

  console.log(`üìã Procesando paso: ${step}, Input: "${userInput}"`);

  switch (step) {
     case 'greeting':
       // Primera interacci√≥n - saludo general
       state.step = 'ask_intention';
       const greetingMessages = [
         '¬°Hola! Bienvenido a nuestro restaurante. ¬øEn qu√© puedo ayudarle?',
         '¬°Buenos d√≠as! Bienvenido. ¬øC√≥mo puedo ayudarle hoy?',
         '¬°Hola! Gracias por llamar. ¬øEn qu√© puedo asistirle?',
         '¬°Buenas tardes! Bienvenido al restaurante. ¬øQu√© necesita?',
         '¬°Hola! Encantado de atenderle. ¬øEn qu√© puedo ayudarle?'
       ];
       return {
         message: getRandomMessage(greetingMessages),
         gather: true
       };

     case 'ask_intention':
       // Confirmar que quiere hacer una reserva
       const intentionResult = handleIntentionResponse(text);
       
       if (intentionResult.action === 'reservation') {
         state.step = 'ask_people';
         const reservationMessages = [
           '¬°Perfecto! Encantado de ayudarle con su reserva. ¬øPara cu√°ntas personas?',
           '¬°Excelente! Me alegra ayudarle con la reserva. ¬øCu√°ntas personas ser√°n?',
           '¬°Muy bien! Con gusto le ayudo. ¬øPara cu√°ntos comensales?',
           '¬°Perfecto! ¬øPara cu√°ntas personas necesita la mesa?',
           '¬°Genial! ¬øCu√°ntas personas van a venir?'
         ];
         return {
           message: getRandomMessage(reservationMessages),
           gather: true
         };
       } else if (intentionResult.action === 'clarify') {
         return {
           message: intentionResult.message,
           gather: true
         };
       } else {
         return {
           message: 'Disculpe, solo puedo ayudarle con reservas. ¬øLe gustar√≠a hacer una reserva?',
           gather: true
         };
       }

     case 'ask_people':
       const people = extractPeopleCount(text);
       if (people) {
         state.data.NumeroReserva = people;
         state.step = 'ask_date';
         const peopleMessages = [
           `Perfecto, ${people} ${people === 1 ? 'persona' : 'personas'}. ¬øPara qu√© fecha?`,
           `Excelente, ${people} ${people === 1 ? 'persona' : 'personas'}. ¬øQu√© d√≠a prefieren?`,
           `Muy bien, ${people} ${people === 1 ? 'persona' : 'personas'}. ¬øPara cu√°ndo?`,
           `Perfecto, ${people} ${people === 1 ? 'persona' : 'personas'}. ¬øPara qu√© d√≠a?`,
           `Genial, ${people} ${people === 1 ? 'persona' : 'personas'}. ¬øCu√°ndo les gustar√≠a venir?`
         ];
         return {
           message: getRandomMessage(peopleMessages),
           gather: true
         };
       } else {
         const errorResponse = handleUnclearResponse(text, 'people');
         return {
           message: errorResponse,
           gather: true
         };
       }

     case 'ask_date':
       const date = extractDate(text);
       if (date) {
         state.data.FechaReserva = date;
         state.step = 'ask_time';
         const dateMessages = [
           `Perfecto, ${formatDateSpanish(date)}. ¬øA qu√© hora?`,
           `Excelente, ${formatDateSpanish(date)}. ¬øA qu√© hora prefieren?`,
           `Muy bien, ${formatDateSpanish(date)}. ¬øA qu√© hora les gustar√≠a venir?`,
           `Perfecto, ${formatDateSpanish(date)}. ¬øQu√© hora les conviene?`,
           `Genial, ${formatDateSpanish(date)}. ¬øA qu√© hora?`
         ];
         return {
           message: getRandomMessage(dateMessages),
           gather: true
         };
       } else {
         const errorResponse = handleUnclearResponse(text, 'date');
         return {
           message: errorResponse,
           gather: true
         };
       }

     case 'ask_time':
       const time = extractTime(text);
       if (time) {
         state.data.HoraReserva = time;
         state.step = 'ask_name';
         const timeMessages = [
           `Perfecto, a las ${time}. ¬øSu nombre?`,
           `Excelente, a las ${time}. ¬øC√≥mo se llama?`,
           `Muy bien, a las ${time}. ¬øSu nombre, por favor?`,
           `Perfecto, a las ${time}. ¬øC√≥mo me dice su nombre?`,
           `Genial, a las ${time}. ¬øSu nombre?`
         ];
         return {
           message: getRandomMessage(timeMessages),
           gather: true
         };
       } else {
         const errorResponse = handleUnclearResponse(text, 'time');
         return {
           message: errorResponse,
           gather: true
         };
       }

     case 'ask_name':
       const name = extractName(text);
       if (name) {
         state.data.NomReserva = name;
         state.step = 'ask_phone';
         const nameMessages = [
           `Perfecto, ${name}. ¬øDesea usar este n√∫mero de tel√©fono para la reserva, o prefiere indicar otro?`,
           `Excelente, ${name}. ¬øUsa este n√∫mero o prefiere dar otro?`,
           `Muy bien, ${name}. ¬øEste tel√©fono est√° bien o quiere otro?`,
           `Perfecto, ${name}. ¬øLe sirve este n√∫mero o prefiere uno diferente?`,
           `Genial, ${name}. ¬øUsa este n√∫mero o necesita otro?`
         ];
         return {
           message: getRandomMessage(nameMessages),
           gather: true
         };
       } else {
         const errorResponse = handleUnclearResponse(text, 'name');
         return {
           message: errorResponse,
           gather: true
         };
       }

    case 'ask_phone':
      // Verificar si quiere usar el n√∫mero actual o dar otro
      if (text.includes('este') || text.includes('mismo') || text.includes('si') || text.includes('s√≠') || text.includes('vale') || text.includes('ok')) {
        // Usa el n√∫mero de la llamada
        state.data.TelefonReserva = state.phone;
        state.step = 'confirm';
        return {
          message: getConfirmationMessage(state.data),
          gather: true
        };
      } else if (text.includes('otro') || text.includes('diferente') || text.includes('no')) {
        // Preguntar por otro n√∫mero
        state.step = 'ask_phone_number';
        return {
          message: '¬øQu√© n√∫mero de tel√©fono prefiere?',
          gather: true
        };
      } else {
        // Intentar extraer un n√∫mero directamente
        const phoneMatch = text.match(/\d{9,}/);
        if (phoneMatch) {
          state.data.TelefonReserva = phoneMatch[0];
          state.step = 'confirm';
          return {
            message: getConfirmationMessage(state.data),
            gather: true
          };
        } else {
          return {
            message: '¬øDesea usar este n√∫mero o prefiere dar otro?',
            gather: true
          };
        }
      }

     case 'ask_phone_number':
       // Extraer el n√∫mero de tel√©fono (puede estar en d√≠gitos o palabras)
       const extractedPhone = extractPhoneNumber(text);
       if (extractedPhone && extractedPhone.length >= 9) {
         state.data.TelefonReserva = extractedPhone;
         state.step = 'confirm';
         return {
           message: getConfirmationMessage(state.data),
           gather: true
         };
       } else {
         const errorResponse = handleUnclearResponse(text, 'phone');
         return {
           message: errorResponse,
           gather: true
         };
       }

     case 'confirm':
       const confirmationResult = handleConfirmationResponse(text);
       
       if (confirmationResult.action === 'confirm') {
         state.step = 'complete';
         const confirmMessages = [
           '¬°Perfecto! Su reserva est√° confirmada. Le esperamos. ¬°Buen d√≠a!',
           '¬°Excelente! Reserva confirmada. Les esperamos. ¬°Que tengan buen d√≠a!',
           '¬°Muy bien! Todo listo. Les esperamos. ¬°Hasta pronto!',
           '¬°Genial! Reserva confirmada. Nos vemos pronto. ¬°Buen d√≠a!',
           '¬°Perfecto! Todo confirmado. Les esperamos. ¬°Que disfruten!'
         ];
         return {
           message: getRandomMessage(confirmMessages),
           gather: false
         };
       } else if (confirmationResult.action === 'modify') {
         return handleModificationRequest(state, confirmationResult.modification);
       } else if (confirmationResult.action === 'restart') {
         state.step = 'ask_people';
         state.data = {};
         return {
           message: 'De acuerdo. Empezamos de nuevo. ¬øPara cu√°ntas personas?',
           gather: true
         };
       } else if (confirmationResult.action === 'clarify') {
         return {
           message: confirmationResult.message,
           gather: true
         };
       } else {
         return {
           message: '¬øEs correcto? Puede decir s√≠, no, o qu√© quiere cambiar.',
           gather: true
         };
       }

    default:
      state.step = 'greeting';
      return {
        message: '¬øEn qu√© puedo ayudarle? ¬øLe gustar√≠a hacer una reserva?',
        gather: true
      };
  }
}

function generateTwiML(response) {
  const { message, gather = true } = response;

  if (gather) {
    // Usar Gather para capturar la respuesta del usuario
    return `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Gather 
    input="speech" 
    action="/api/twilio-call" 
    method="POST"
    language="es-ES"
     speechTimeout="1"
     timeout="3">
    <Say voice="Google.es-ES-Neural2-B" language="es-ES">${escapeXml(message)}</Say>
  </Gather>
   <Say voice="Google.es-ES-Neural2-B" language="es-ES">${getRandomMessage(['No escuch√© respuesta. ¬øSigue ah√≠?', 'Disculpe, no escuch√©. ¬øSigue ah√≠?', '¬øEst√° ah√≠? No escuch√© nada.', '¬øSigue en la l√≠nea? No escuch√© respuesta.', 'Disculpe, ¬øpodr√≠a repetir? No escuch√© bien.'])}</Say>
  <Redirect>/api/twilio-call</Redirect>
</Response>`;
  } else {
    // Solo decir el mensaje y colgar
    return `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="Google.es-ES-Neural2-B" language="es-ES">${escapeXml(message)}</Say>
  <Pause length="1"/>
  <Hangup/>
</Response>`;
  }
}

async function saveReservation(state) {
  try {
    console.log('üíæ Guardando reserva en base de datos...');
    
    const data = state.data;
    
    // Validar datos
    const validacion = validarReserva(data);
    if (!validacion.valido) {
      console.error('‚ùå Validaci√≥n fallida:', validacion.errores);
      return false;
    }

    // Preparar conversaci√≥n completa en formato Markdown
    const conversacionCompleta = generateMarkdownConversation(state);

    // Combinar fecha y hora
    const dataCombinada = combinarFechaHora(data.FechaReserva, data.HoraReserva);

    // Conectar a base de datos
    const connection = await createConnection();
    
    try {
      await connection.beginTransaction();

      // 1. Insertar o actualizar cliente
      const clienteQuery = `
        INSERT INTO CLIENT (NOM_COMPLET, TELEFON, DATA_ULTIMA_RESERVA) 
        VALUES (?, ?, NOW()) 
        ON DUPLICATE KEY UPDATE 
          NOM_COMPLET = VALUES(NOM_COMPLET), 
          DATA_ULTIMA_RESERVA = NOW()
      `;
      
      await connection.execute(clienteQuery, [
        data.NomReserva,
        data.TelefonReserva
      ]);

      console.log('‚úÖ Cliente insertado/actualizado');

      // 2. Insertar reserva
      const reservaQuery = `
        INSERT INTO RESERVA 
        (data_reserva, num_persones, telefon, nom_persona_reserva, observacions, conversa_completa) 
        VALUES (?, ?, ?, ?, ?, ?)
      `;
      
      const [result] = await connection.execute(reservaQuery, [
        dataCombinada,
        data.NumeroReserva,
        data.TelefonReserva,
        data.NomReserva,
        'Reserva realizada por tel√©fono (Twilio)',
        conversacionCompleta
      ]);

      const idReserva = result.insertId;
      console.log('‚úÖ Reserva guardada con ID:', idReserva);

      await connection.commit();
      return true;

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      await connection.end();
    }

  } catch (error) {
    console.error('‚ùå Error guardando reserva:', error);
    return false;
  }
}

// Funciones auxiliares de extracci√≥n

function getRandomMessage(messages) {
  const randomIndex = Math.floor(Math.random() * messages.length);
  return messages[randomIndex];
}

function handleConfirmationResponse(text) {
  // Palabras de confirmaci√≥n positiva
  const positiveWords = [
    'si', 's√≠', 'correcto', 'confirmo', 'perfecto', 'bien', 'vale', 'ok', 'okay',
    'exacto', 'eso es', 'as√≠ es', 'est√° bien', 'me parece bien', 'de acuerdo',
    'confirmado', 'acepto', 'procedo', 'adelante', 'contin√∫o'
  ];
  
  // Palabras de negaci√≥n
  const negativeWords = [
    'no', 'incorrecto', 'mal', 'error', 'cambiar', 'modificar', 'corregir',
    'no es', 'no est√° bien', 'no me parece', 'discrepo', 'no acepto'
  ];
  
  // Palabras para reiniciar
  const restartWords = [
    'empezar de nuevo', 'volver a empezar', 'reiniciar', 'otra vez', 'de nuevo',
    'cambiar todo', 'empezamos otra vez', 'resetear'
  ];
  
  const lowerText = text.toLowerCase();
  
  // Verificar confirmaci√≥n positiva
  if (positiveWords.some(word => lowerText.includes(word))) {
    return { action: 'confirm' };
  }
  
  // Verificar negaci√≥n
  if (negativeWords.some(word => lowerText.includes(word))) {
    return { action: 'clarify', message: 'Entiendo. ¬øQu√© le gustar√≠a cambiar? Puede decir cambiar personas, cambiar fecha, cambiar hora, cambiar nombre o cambiar tel√©fono.' };
  }
  
  // Verificar reinicio completo
  if (restartWords.some(word => lowerText.includes(word))) {
    return { action: 'restart' };
  }
  
  // Detectar modificaciones espec√≠ficas
  const modifications = detectSpecificModifications(lowerText);
  if (modifications.length > 0) {
    return { action: 'modify', modification: modifications[0] };
  }
  
  // Respuesta ambigua
  return { action: 'clarify', message: '¬øEs correcto? Puede decir s√≠ para confirmar, no para cambiar algo, o qu√© espec√≠ficamente quiere modificar.' };
}

function detectSpecificModifications(text) {
  const modifications = [];
  
  // Detectar cambios espec√≠ficos
  if (text.includes('personas') || text.includes('gente') || text.includes('comensales') || text.includes('n√∫mero de personas')) {
    modifications.push('people');
  }
  if (text.includes('fecha') || text.includes('d√≠a') || text.includes('d√≠a') || text.includes('cuando')) {
    modifications.push('date');
  }
  if (text.includes('hora') || text.includes('tiempo') || text.includes('a qu√© hora')) {
    modifications.push('time');
  }
  if (text.includes('nombre') || text.includes('como me llamo') || text.includes('mi nombre')) {
    modifications.push('name');
  }
  if (text.includes('tel√©fono') || text.includes('n√∫mero') || text.includes('tel√©fono')) {
    modifications.push('phone');
  }
  
  return modifications;
}

function handleModificationRequest(state, modification) {
  switch (modification) {
    case 'people':
      state.step = 'ask_people';
      return {
        message: 'Perfecto. ¬øPara cu√°ntas personas?',
        gather: true
      };
      
    case 'date':
      state.step = 'ask_date';
      return {
        message: 'Perfecto. ¬øPara qu√© fecha?',
        gather: true
      };
      
    case 'time':
      state.step = 'ask_time';
      return {
        message: 'Perfecto. ¬øA qu√© hora?',
        gather: true
      };
      
    case 'name':
      state.step = 'ask_name';
      return {
        message: 'Perfecto. ¬øSu nombre?',
        gather: true
      };
      
    case 'phone':
      state.step = 'ask_phone';
      return {
        message: 'Perfecto. ¬øDesea usar este n√∫mero o prefiere otro?',
        gather: true
      };
      
    default:
      return {
        message: '¬øQu√© espec√≠ficamente quiere cambiar?',
        gather: true
      };
  }
}

function handleIntentionResponse(text) {
  // Palabras de reserva directa
  const directReservationWords = [
    'reservar', 'reserva', 'mesa', 'quiero reservar', 'necesito reservar', 
    'me gustar√≠a reservar', 'quisiera reservar', 'deseo reservar', 
    'hacer una reserva', 'reservar mesa', 'quiero mesa'
  ];
  
  // Palabras de intenci√≥n general
  const generalIntentionWords = [
    'quiero', 'necesito', 'me gustar√≠a', 'quisiera', 'deseo', 'quer√≠a',
    'si', 's√≠', 'vale', 'bueno', 'perfecto', 'adelante'
  ];
  
  // Palabras de negaci√≥n o no reserva
  const negativeWords = [
    'no', 'nada', 'solo llamaba', 'informaci√≥n', 'pregunta', 'duda',
    'cancelar', 'cancelaci√≥n', 'no reserva'
  ];
  
  const lowerText = text.toLowerCase();
  
  // Verificar reserva directa
  if (directReservationWords.some(word => lowerText.includes(word))) {
    return { action: 'reservation' };
  }
  
  // Verificar negaci√≥n
  if (negativeWords.some(word => lowerText.includes(word))) {
    return { 
      action: 'clarify', 
      message: 'Entiendo. Si cambia de opini√≥n y quiere hacer una reserva, solo d√≠gamelo.' 
    };
  }
  
  // Verificar intenci√≥n general (asumir que es para reserva)
  if (generalIntentionWords.some(word => lowerText.includes(word))) {
    return { action: 'reservation' };
  }
  
  // Respuesta ambigua
  return { 
    action: 'clarify', 
    message: '¬øLe gustar√≠a hacer una reserva para nuestro restaurante?' 
  };
}

function handleUnclearResponse(text, field) {
  const responses = {
    people: [
      'Disculpe, no entend√≠. ¬øCu√°ntas personas ser√°n?',
      '¬øPara cu√°ntas personas? D√≠game un n√∫mero del 1 al 20.',
      'No capt√© bien. ¬øCu√°ntas personas van a venir?',
      '¬øPodr√≠a repetir? ¬øPara cu√°ntas personas?',
      'Disculpe, ¬øcu√°ntas personas ser√°n en total?'
    ],
    date: [
      'No entend√≠ bien la fecha. ¬øQu√© d√≠a prefieren?',
      '¬øPara qu√© d√≠a? Pueden decir ma√±ana, pasado ma√±ana, o un d√≠a espec√≠fico.',
      'Disculpe, no capt√© la fecha. ¬øQu√© d√≠a les conviene?',
      '¬øPodr√≠an repetir? ¬øPara qu√© fecha?',
      'No entend√≠. ¬øQu√© d√≠a quieren venir?'
    ],
    time: [
      'No entend√≠ bien la hora. ¬øA qu√© hora prefieren?',
      '¬øA qu√© hora? Pueden decir por ejemplo: las ocho, las ocho y media...',
      'Disculpe, no capt√© la hora. ¬øA qu√© hora les gustar√≠a venir?',
      '¬øPodr√≠an repetir? ¬øA qu√© hora?',
      'No entend√≠. ¬øA qu√© hora quieren la reserva?'
    ],
    name: [
      'Disculpe, no entend√≠ bien su nombre. ¬øC√≥mo se llama?',
      '¬øSu nombre? Por favor, d√≠gamelo despacio.',
      'No capt√© su nombre. ¬øPodr√≠a repetirlo?',
      'Disculpe, ¬øc√≥mo se llama?',
      '¬øPodr√≠a decirme su nombre otra vez?'
    ],
    phone: [
      'No entend√≠ bien el n√∫mero. ¬øPodr√≠a decirlo d√≠gito por d√≠gito?',
      '¬øEl n√∫mero de tel√©fono? D√≠galo despacio, n√∫mero por n√∫mero.',
      'Disculpe, no capt√© el tel√©fono. ¬øPuede repetirlo?',
      '¬øPodr√≠a repetir el n√∫mero? D√≠gito por d√≠gito.',
      'No entend√≠. ¬øSu n√∫mero de tel√©fono?'
    ]
  };
  
  // Seleccionar respuesta aleatoria para evitar monoton√≠a
  const fieldResponses = responses[field] || ['Disculpe, no entend√≠. ¬øPuede repetir?'];
  return getRandomMessage(fieldResponses);
}

function isReservationRequest(text) {
  const reservationWords = [
    'reservar', 'reserva', 'mesa', 'quiero', 'necesito', 
    'me gustar√≠a', 'quisiera', 'deseo', 'quer√≠a',
    'hacer una reserva', 'reservar mesa', 'si', 's√≠', 'vale'
  ];
  return reservationWords.some(word => text.includes(word));
}

function extractPeopleCount(text) {
  const wordToNumber = {
    'uno': 1, 'una': 1, 'dos': 2, 'tres': 3, 'cuatro': 4, 'cinco': 5,
    'seis': 6, 'siete': 7, 'ocho': 8, 'nueve': 9, 'diez': 10,
    'once': 11, 'doce': 12, 'trece': 13, 'catorce': 14, 'quince': 15
  };

  // Detectar palabras de correcci√≥n
  const correctionWords = ['no', 'mejor', 'espera', 'espere', 'perd√≥n', 'disculpa', 'corrijo'];
  const hasCorrection = correctionWords.some(word => text.includes(word));

  let foundNumbers = [];

  // Buscar n√∫meros en palabras
  for (const [word, number] of Object.entries(wordToNumber)) {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    let match;
    while ((match = regex.exec(text)) !== null) {
      foundNumbers.push({ number, position: match.index });
    }
  }

  // Buscar n√∫meros digitales
  const digitMatches = text.matchAll(/\b(\d+)\b/g);
  for (const match of digitMatches) {
    const count = parseInt(match[1]);
    if (count >= 1 && count <= 20) {
      foundNumbers.push({ number: count, position: match.index });
    }
  }

  if (foundNumbers.length === 0) return null;

  // Si hay correcci√≥n o m√∫ltiples n√∫meros, tomar el √∫ltimo
  if (hasCorrection || foundNumbers.length > 1) {
    foundNumbers.sort((a, b) => b.position - a.position);
    return foundNumbers[0].number;
  }

  // Si solo hay un n√∫mero, devolverlo
  return foundNumbers[0].number;
}

function extractDate(text) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  console.log('üîç extractDate recibi√≥:', text);

  // Detectar palabras de correcci√≥n
  const correctionWords = ['no', 'mejor', 'espera', 'espere', 'perd√≥n', 'disculpa', 'corrijo'];
  const hasCorrection = correctionWords.some(word => text.includes(word));

  let foundDates = [];

  // Si hay correcci√≥n, buscar la √∫ltima fecha mencionada
  // Dividir el texto en partes para analizar la √∫ltima despu√©s de la correcci√≥n
  let textToAnalyze = text;
  if (hasCorrection) {
    // Buscar la √∫ltima ocurrencia de palabras de correcci√≥n
    let lastCorrectionIndex = -1;
    correctionWords.forEach(word => {
      const index = text.lastIndexOf(word);
      if (index > lastCorrectionIndex) {
        lastCorrectionIndex = index;
      }
    });
    // Analizar solo el texto despu√©s de la correcci√≥n
    if (lastCorrectionIndex !== -1) {
      textToAnalyze = text.substring(lastCorrectionIndex);
    }
  }

  // Manejar "pasado ma√±ana" antes que "ma√±ana"
  if (textToAnalyze.includes('pasado ma√±ana') || (textToAnalyze.includes('pasado') && textToAnalyze.includes('ma√±ana'))) {
    const date = new Date(today);
    date.setDate(date.getDate() + 2);
    console.log('‚úÖ Detectado: pasado ma√±ana');
    return formatDateISO(date);
  }
  
  // Manejar "ma√±ana" pero no "pasado ma√±ana"
  if (textToAnalyze.includes('ma√±ana') && !textToAnalyze.includes('pasado')) {
    const date = new Date(today);
    date.setDate(date.getDate() + 1);
    console.log('‚úÖ Detectado: ma√±ana');
    return formatDateISO(date);
  }
  
  if (textToAnalyze.includes('hoy')) {
    console.log('‚úÖ Detectado: hoy');
    return formatDateISO(today);
  }

  // Mapeo de nombres de meses en espa√±ol (ANTES de d√≠as de la semana para priorizar)
  const monthNames = {
    'enero': 1, 'febrero': 2, 'marzo': 3, 'abril': 4,
    'mayo': 5, 'junio': 6, 'julio': 7, 'agosto': 8,
    'septiembre': 9, 'octubre': 10, 'noviembre': 11, 'diciembre': 12
  };

  // Intentar extraer fecha con nombre de mes: "10 de octubre", "15 de enero"
  for (const [monthName, monthNumber] of Object.entries(monthNames)) {
    if (textToAnalyze.includes(monthName)) {
      console.log(`‚úÖ Detectado mes: ${monthName}`);
      
      // Buscar el n√∫mero antes del mes (m√°s preciso)
      const patterns = [
        new RegExp(`(\\d{1,2})\\s*de\\s*${monthName}`, 'i'),  // "10 de octubre"
        new RegExp(`(\\d{1,2})\\s*${monthName}`, 'i'),         // "10 octubre"
        new RegExp(`${monthName}\\s*(\\d{1,2})`, 'i'),         // "octubre 10"
      ];
      
      for (const pattern of patterns) {
        const match = textToAnalyze.match(pattern);
        if (match) {
          const day = parseInt(match[1]);
          console.log(`‚úÖ Detectado d√≠a: ${day}`);
          
          if (day >= 1 && day <= 31) {
            const year = today.getFullYear();
            try {
              const date = new Date(year, monthNumber - 1, day);
              // Si la fecha es anterior a hoy, asumir que es el a√±o siguiente
              if (date < today) {
                date.setFullYear(year + 1);
              }
              console.log(`‚úÖ Fecha procesada: ${formatDateISO(date)}`);
              return formatDateISO(date);
            } catch (e) {
              console.log('‚ùå Error creando fecha:', e);
              return null;
            }
          }
        }
      }
      
      // Si no encontr√≥ patr√≥n espec√≠fico, buscar cualquier n√∫mero
      const dayMatches = [...textToAnalyze.matchAll(/\b(\d{1,2})\b/g)];
      if (dayMatches.length > 0) {
        const day = parseInt(dayMatches[0][1]);
        if (day >= 1 && day <= 31) {
          const year = today.getFullYear();
          try {
            const date = new Date(year, monthNumber - 1, day);
            if (date < today) {
              date.setFullYear(year + 1);
            }
            console.log(`‚úÖ Fecha procesada (fallback): ${formatDateISO(date)}`);
            return formatDateISO(date);
          } catch (e) {
            return null;
          }
        }
      }
    }
  }

  // Detectar d√≠as de la semana (DESPU√âS de los meses)
  const daysOfWeek = {
    'lunes': 1, 'martes': 2, 'mi√©rcoles': 3, 'miercoles': 3,
    'jueves': 4, 'viernes': 5, 's√°bado': 6, 'sabado': 6, 'domingo': 0
  };

  for (const [dayName, dayNumber] of Object.entries(daysOfWeek)) {
    if (textToAnalyze.includes(dayName)) {
      console.log(`‚úÖ Detectado d√≠a de la semana: ${dayName}`);
      const currentDay = today.getDay(); // 0=domingo, 1=lunes, etc.
      let daysUntil = dayNumber - currentDay;
      
      // Si el d√≠a ya pas√≥ esta semana, ir a la pr√≥xima semana
      if (daysUntil <= 0) {
        daysUntil += 7;
      }
      
      // Si dice "que viene" o "pr√≥ximo", asegurar que es la pr√≥xima semana
      if (textToAnalyze.includes('que viene') || textToAnalyze.includes('pr√≥ximo') || textToAnalyze.includes('proximo')) {
        if (daysUntil < 7) {
          daysUntil += 7;
        }
      }
      
      const date = new Date(today);
      date.setDate(date.getDate() + daysUntil);
      return formatDateISO(date);
    }
  }

  // Intentar extraer fecha num√©rica: "10/10", "10-10"
  const dateMatch = textToAnalyze.match(/(\d{1,2})[\/\-\s](?:de\s)?(\d{1,2})/);
  if (dateMatch) {
    const day = parseInt(dateMatch[1]);
    const month = parseInt(dateMatch[2]);
    const year = today.getFullYear();
    
    try {
      const date = new Date(year, month - 1, day);
      if (date < today) {
        date.setFullYear(year + 1);
      }
      return formatDateISO(date);
    } catch (e) {
      return null;
    }
  }

  return null;
}

function extractTime(text) {
  const wordToNumber = {
    'una': 1, 'dos': 2, 'tres': 3, 'cuatro': 4, 'cinco': 5,
    'seis': 6, 'siete': 7, 'ocho': 8, 'nueve': 9, 'diez': 10,
    'once': 11, 'doce': 12
  };

  // Detectar palabras de correcci√≥n
  const correctionWords = ['no', 'mejor', 'espera', 'espere', 'perd√≥n', 'disculpa', 'corrijo'];
  const hasCorrection = correctionWords.some(word => text.includes(word));

  let foundTimes = [];

  // Buscar horas en palabras
  for (const [word, number] of Object.entries(wordToNumber)) {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    let match;
    while ((match = regex.exec(text)) !== null) {
      let hours = number;
      let minutes = 0;

      if (text.includes('media') || text.includes('treinta')) {
        minutes = 30;
      } else if (text.includes('cuarto') || text.includes('quince')) {
        minutes = 15;
      }

      if (text.includes('noche') || text.includes('tarde')) {
        if (hours < 12) hours += 12;
      }

      if (hours >= 0 && hours <= 23) {
        foundTimes.push({
          time: `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`,
          position: match.index
        });
      }
    }
  }

  // Buscar horas en formato digital
  const timeMatches = text.matchAll(/\b(\d{1,2})(?::(\d{2}))?\b/g);
  for (const match of timeMatches) {
    let hours = parseInt(match[1]);
    const minutes = match[2] ? parseInt(match[2]) : 0;

    if (text.includes('noche') || text.includes('tarde')) {
      if (hours < 12) hours += 12;
    }

    if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
      foundTimes.push({
        time: `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`,
        position: match.index
      });
    }
  }

  if (foundTimes.length === 0) return null;

  // Si hay correcci√≥n o m√∫ltiples horas, tomar la √∫ltima
  if (hasCorrection || foundTimes.length > 1) {
    foundTimes.sort((a, b) => b.position - a.position);
    return foundTimes[0].time;
  }

  // Si solo hay una hora, devolverla
  return foundTimes[0].time;
}

function extractName(text) {
  // Limpiar el texto
  const cleaned = text
    .replace(/mi nombre es/gi, '')
    .replace(/me llamo/gi, '')
    .replace(/soy/gi, '')
    .trim();
  
  if (cleaned.length > 1) {
    // Capitalizar cada palabra
    return cleaned
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  }
  
  return null;
}

function extractPhoneNumber(text) {
  // Primero intentar extraer n√∫meros directamente
  const directMatch = text.match(/\d{9,}/);
  if (directMatch) {
    return directMatch[0];
  }

  // Mapeo de palabras a d√≠gitos
  const wordToDigit = {
    'cero': '0', 'uno': '1', 'una': '1', 'dos': '2', 'tres': '3', 
    'cuatro': '4', 'cinco': '5', 'seis': '6', 'siete': '7', 
    'ocho': '8', 'nueve': '9'
  };

  // Convertir palabras a d√≠gitos
  let phoneNumber = '';
  const words = text.split(/\s+/);
  
  for (const word of words) {
    const cleanWord = word.toLowerCase().replace(/[,\.]/g, '');
    if (wordToDigit[cleanWord]) {
      phoneNumber += wordToDigit[cleanWord];
    } else if (/^\d$/.test(cleanWord)) {
      // Si ya es un d√≠gito, agregarlo
      phoneNumber += cleanWord;
    }
  }

  // Si tenemos al menos 9 d√≠gitos, retornar
  if (phoneNumber.length >= 9) {
    return phoneNumber;
  }

  return null;
}

function getConfirmationMessage(data) {
  const phoneFormatted = formatPhoneForSpeech(data.TelefonReserva);
  return `Confirmo: ${data.NumeroReserva} ${data.NumeroReserva === 1 ? 'persona' : 'personas'}, ${formatDateSpanish(data.FechaReserva)} a las ${data.HoraReserva}, a nombre de ${data.NomReserva}, tel√©fono ${phoneFormatted}. ¬øEs correcto?`;
}

function formatPhoneForSpeech(phone) {
  // Limpiar el tel√©fono de caracteres no num√©ricos
  const cleanPhone = phone.replace(/\D/g, '');
  
  // Convertir cada d√≠gito en su palabra en espa√±ol con espacios para pausas
  const digitWords = {
    '0': 'cero', '1': 'uno', '2': 'dos', '3': 'tres', '4': 'cuatro',
    '5': 'cinco', '6': 'seis', '7': 'siete', '8': 'ocho', '9': 'nueve'
  };
  
  // Convertir cada d√≠gito y a√±adir comas para pausas naturales cada 3 d√≠gitos
  let result = '';
  for (let i = 0; i < cleanPhone.length; i++) {
    result += digitWords[cleanPhone[i]];
    // A√±adir una pausa despu√©s de cada 3 d√≠gitos (excepto al final)
    if ((i + 1) % 3 === 0 && i !== cleanPhone.length - 1) {
      result += ', ';
    } else if (i !== cleanPhone.length - 1) {
      result += ' ';
    }
  }
  
  return result;
}

function formatDateISO(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function formatDateSpanish(dateStr) {
  const [year, month, day] = dateStr.split('-');
  const months = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
                  'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
  return `${parseInt(day)} de ${months[parseInt(month) - 1]}`;
}

function escapeXml(text) {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

function generateMarkdownConversation(state) {
  const { conversationHistory, phone, data } = state;
  const timestamp = new Date().toISOString();
  
  let markdown = `# üìû Conversaci√≥n de Reserva\n\n`;
  
  // Informaci√≥n de la llamada
  markdown += `## üìã Informaci√≥n de la Llamada\n`;
  markdown += `- **Tel√©fono**: ${phone}\n`;
  markdown += `- **Fecha**: ${new Date().toLocaleDateString('es-ES')}\n`;
  markdown += `- **Hora**: ${new Date().toLocaleTimeString('es-ES')}\n`;
  markdown += `- **Sistema**: Twilio (Hard-coded)\n`;
  markdown += `- **Estado**: ${state.step === 'complete' ? '‚úÖ Completada' : '‚ö†Ô∏è Incompleta'}\n\n`;
  
  // Datos de la reserva (si est√°n disponibles)
  if (data && Object.keys(data).length > 0) {
    markdown += `## üçΩÔ∏è Datos de la Reserva\n`;
    if (data.NumeroReserva) markdown += `- **Personas**: ${data.NumeroReserva}\n`;
    if (data.FechaReserva) markdown += `- **Fecha**: ${formatDateSpanish(data.FechaReserva)}\n`;
    if (data.HoraReserva) markdown += `- **Hora**: ${data.HoraReserva}\n`;
    if (data.NomReserva) markdown += `- **Nombre**: ${data.NomReserva}\n`;
    if (data.TelefonReserva) markdown += `- **Tel√©fono Reserva**: ${data.TelefonReserva}\n`;
    markdown += `\n`;
  }
  
  // Conversaci√≥n paso a paso
  markdown += `## üí¨ Transcripci√≥n de la Conversaci√≥n\n\n`;
  
  conversationHistory.forEach((entry, index) => {
    const time = new Date(entry.timestamp).toLocaleTimeString('es-ES');
    const step = index + 1;
    
    if (entry.role === 'user') {
      markdown += `### ${step}. üë§ Cliente (${time})\n`;
      markdown += `> ${entry.message}\n\n`;
    } else {
      markdown += `### ${step}. ü§ñ Bot (${time})\n`;
      markdown += `${entry.message}\n\n`;
    }
  });
  
  // An√°lisis de la conversaci√≥n
  markdown += `## üìä An√°lisis de la Conversaci√≥n\n\n`;
  markdown += `- **Total de intercambios**: ${conversationHistory.length}\n`;
  markdown += `- **Duraci√≥n estimada**: ${Math.ceil(conversationHistory.length * 15)} segundos\n`;
  
  // Contar pasos completados
  const stepsCompleted = ['ask_people', 'ask_date', 'ask_time', 'ask_name', 'ask_phone'].filter(step => {
    return state.data[step === 'ask_people' ? 'NumeroReserva' : 
                      step === 'ask_date' ? 'FechaReserva' :
                      step === 'ask_time' ? 'HoraReserva' :
                      step === 'ask_name' ? 'NomReserva' :
                      'TelefonReserva'];
  }).length;
  
  markdown += `- **Pasos completados**: ${stepsCompleted}/5\n`;
  
  // Detectar si fue exitosa
  const wasSuccessful = state.step === 'complete';
  markdown += `- **Resultado**: ${wasSuccessful ? '‚úÖ Reserva completada exitosamente' : '‚ùå Conversaci√≥n incompleta'}\n\n`;
  
  // Detectar problemas comunes y sugerir mejoras
  markdown += `## üîç An√°lisis de Problemas y Mejoras\n\n`;
  
  const issues = [];
  const suggestions = [];
  const history = conversationHistory.map(h => h.message.toLowerCase());
  
  // 1. DETECTAR REPETICIONES
  const repeatedMessages = history.filter((msg, index) => 
    history.indexOf(msg) !== index
  );
  if (repeatedMessages.length > 0) {
    issues.push(`‚ö†Ô∏è Mensajes repetidos detectados (${repeatedMessages.length})`);
    suggestions.push(`üí° **Soluci√≥n**: Implementar m√°s variaciones de respuestas para evitar repetici√≥n`);
    suggestions.push(`üí° **T√©cnica**: Usar arrays de 10-15 frases diferentes por cada paso`);
  }
  
  // 2. DETECTAR ERRORES DE COMPRENSI√ìN
  const errorMessages = history.filter(msg => 
    msg.includes('no entend√≠') || msg.includes('disculpe') || msg.includes('perd√≥n')
  );
  if (errorMessages.length > 0) {
    issues.push(`‚ö†Ô∏è Errores de comprensi√≥n: ${errorMessages.length}`);
    
    // Analizar QU√â no entendi√≥
    const unclearResponses = conversationHistory.filter(entry => 
      entry.role === 'bot' && (
        entry.message.includes('no entend√≠') || 
        entry.message.includes('Disculpe') || 
        entry.message.includes('Perd√≥n')
      )
    );
    
    if (unclearResponses.length > 0) {
      suggestions.push(`üí° **Problema espec√≠fico**: El bot no entendi√≥ ${unclearResponses.length} respuestas del cliente`);
      suggestions.push(`üí° **Soluci√≥n**: Mejorar patrones regex o implementar Gemini para comprensi√≥n contextual`);
    }
  }
  
  // 3. DETECTAR CONVERSACI√ìN MUY LARGA
  if (conversationHistory.length > 15) {
    issues.push(`‚ö†Ô∏è Conversaci√≥n muy larga (${conversationHistory.length} intercambios)`);
    suggestions.push(`üí° **Problema**: Conversaci√≥n excede el promedio ideal de 10-12 intercambios`);
    suggestions.push(`üí° **Causa posible**: M√∫ltiples errores de comprensi√≥n o cliente indeciso`);
    suggestions.push(`üí° **Soluci√≥n**: Reducir timeouts y mejorar comprensi√≥n para conversaciones m√°s eficientes`);
  }
  
  // 4. DETECTAR CONVERSACIONES MUY CORTAS (posible problema)
  if (conversationHistory.length < 5 && state.step !== 'complete') {
    issues.push(`‚ö†Ô∏è Conversaci√≥n muy corta (${conversationHistory.length} intercambios)`);
    suggestions.push(`üí° **Problema**: Conversaci√≥n termin√≥ prematuramente`);
    suggestions.push(`üí° **Posibles causas**: Cliente colg√≥, error t√©cnico, o bot muy agresivo`);
  }
  
  // 5. DETECTAR PATRONES DE TIMEOUT
  const timeoutMessages = history.filter(msg => 
    msg.includes('no escuch√©') || msg.includes('¬øsigue ah√≠?')
  );
  if (timeoutMessages.length > 0) {
    issues.push(`‚ö†Ô∏è Timeouts detectados (${timeoutMessages.length})`);
    suggestions.push(`üí° **Problema**: El bot cort√≥ al cliente ${timeoutMessages.length} vez(es)`);
    suggestions.push(`üí° **Soluci√≥n**: Aumentar speechTimeout de 1s a 2s o ajustar seg√∫n el cliente`);
  }
  
  // 6. DETECTAR CORRECCIONES EXCESIVAS
  const correctionWords = history.filter(msg => 
    msg.includes('no, mejor') || msg.includes('espera') || msg.includes('cambiar')
  );
  if (correctionWords.length > 2) {
    issues.push(`‚ö†Ô∏è M√∫ltiples correcciones detectadas (${correctionWords.length})`);
    suggestions.push(`üí° **Problema**: Cliente cambi√≥ de opini√≥n muchas veces`);
    suggestions.push(`üí° **Soluci√≥n**: Mejorar extracci√≥n para capturar la correcci√≥n final autom√°ticamente`);
  }
  
  // 7. AN√ÅLISIS DE FLUJO
  const userResponses = conversationHistory.filter(h => h.role === 'user');
  const avgResponseLength = userResponses.reduce((sum, r) => sum + r.message.length, 0) / userResponses.length;
  
  if (avgResponseLength > 50) {
    issues.push(`‚ö†Ô∏è Respuestas del cliente muy largas (promedio: ${Math.round(avgResponseLength)} chars)`);
    suggestions.push(`üí° **Problema**: Cliente dice demasiado en cada respuesta`);
    suggestions.push(`üí° **Soluci√≥n**: Preguntas m√°s espec√≠ficas para obtener respuestas m√°s cortas`);
  }
  
  // MOSTRAR RESULTADOS
  if (issues.length === 0) {
    markdown += `‚úÖ **Conversaci√≥n √≥ptima** - No se detectaron problemas significativos\n\n`;
    markdown += `üéØ **M√©tricas excelentes**:\n`;
    markdown += `- Conversaci√≥n fluida y eficiente\n`;
    markdown += `- Sin errores de comprensi√≥n\n`;
    markdown += `- Duraci√≥n apropiada\n`;
    markdown += `- Cliente satisfecho\n\n`;
  } else {
    markdown += `## üìã Problemas Detectados\n\n`;
    issues.forEach((issue, index) => {
      markdown += `${index + 1}. ${issue}\n`;
    });
    
    markdown += `\n## üí° Sugerencias de Mejora\n\n`;
    suggestions.forEach((suggestion, index) => {
      markdown += `${index + 1}. ${suggestion}\n`;
    });
    
    // Calcular puntuaci√≥n de calidad
    const qualityScore = Math.max(0, 100 - (issues.length * 15) - (conversationHistory.length - 10) * 2);
    markdown += `\n## üìä Puntuaci√≥n de Calidad\n`;
    markdown += `- **Score**: ${qualityScore}/100\n`;
    markdown += `- **Estado**: ${qualityScore >= 80 ? 'üü¢ Excelente' : qualityScore >= 60 ? 'üü° Aceptable' : 'üî¥ Necesita Mejoras'}\n\n`;
  }
  
  markdown += `\n---\n`;
  markdown += `*Generado autom√°ticamente el ${new Date().toLocaleString('es-ES')}*\n`;
  
  return markdown;
}


